//! Internal node types for DAG execution.
//!
//! Provides type erasure to store tasks with different types in a single collection.
//! The public API remains fully type-safe; type erasure is purely an internal implementation detail.
//!
//! - **TypedNode\<T\>**: Stores a task with full type information
//! - **ExecutableNode**: Trait for executing type-erased tasks

use std::any::Any;
use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;

use crate::error::DagError;
use crate::task::Task;
use crate::types::NodeId;

/// Type-erased async execution result (Arc-wrapped for efficient fanout)
type ExecuteFuture =
    Pin<Box<dyn Future<Output = Result<Arc<dyn Any + Send + Sync>, DagError>> + Send>>;

/// Internal trait for executing heterogeneous tasks.
///
/// This trait provides type erasure necessary for storing different task types in a single
/// collection. While the public API (Task, Handle, Node) is fully type-safe, internally we
/// need dynamic dispatch to execute tasks with different input/output types.
///
/// This is the ONLY place where type erasure occurs - tasks are created with full type
/// information and only erased at this trait boundary.
///
/// This is an implementation detail and not part of the public API.
pub(crate) trait ExecutableNode: Send {
    /// Execute the task with type-erased inputs and output
    ///
    /// The TypedNode implementation knows the concrete types and can safely downcast.
    /// Consumes the node and returns the output value.
    fn execute_with_deps(
        self: Box<Self>,
        dependencies: Vec<Arc<dyn Any + Send + Sync>>,
    ) -> ExecuteFuture;
}

/// Fully-typed node storage for a single task.
///
/// Stores a task of type T. Implements ExecutableNode for type erasure,
/// allowing heterogeneous tasks to be stored in a single Vec.
///
/// # Ownership Model
///
/// The task is owned directly (no Mutex needed) and consumed during execution.
/// Each task executes exactly once, taking ownership and producing an output.
///
/// The output is also returned from execute_with_deps for central storage.
pub(crate) struct TypedNode<T: Task> {
    pub(crate) id: NodeId,
    pub(crate) task: T,
}

impl<T: Task + 'static> TypedNode<T> {
    pub(crate) fn new(id: NodeId, task: T) -> Self {
        Self { id, task }
    }
}

impl<T: Task + 'static> ExecutableNode for TypedNode<T>
where
    T::Input: 'static + Clone,
    T::Output: 'static + Clone,
{
    fn execute_with_deps(
        self: Box<Self>,
        dependencies: Vec<Arc<dyn Any + Send + Sync>>,
    ) -> ExecuteFuture {
        Box::pin(async move {
            // Use the task's extract_and_run method which has inline extraction logic
            // generated by the #[task] macro. This allows ANY type to work without
            // requiring ExtractInput trait implementations.
            let output = match self.task.extract_and_run(dependencies).await {
                Ok(output) => output,
                Err(_msg) => {
                    // Failed to extract input - likely type mismatch.
                    // This should technically be infallible, so it might be worth removing in the future.
                    return Err(DagError::InvalidDependency { task_id: self.id.0 });
                }
            };

            // Arc Wrapping Strategy:
            // Wrap output in Arc ONCE for efficient fan-out sharing.
            // For 1:N dependencies, this enables O(1) sharing (Arc clone = atomic increment)
            // instead of O(N) cloning (N deep copies of output data).
            // Downstream tasks receive &T after extraction from Arc.
            let arc_output = Arc::new(output);

            // Return Arc-wrapped output (for storage by runner)
            Ok(arc_output as Arc<dyn Any + Send + Sync>)
        })
    }
}

#[cfg(test)]
mod tests;
